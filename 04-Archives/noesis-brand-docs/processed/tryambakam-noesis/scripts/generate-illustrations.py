#!/usr/bin/env python3
"""
Tryambakam Noesis — Illustrations + Icons (5A-5D)
Generated by Brandmint pipeline engine.

Provider: fal
"""
import os, sys, subprocess, requests
from dotenv import load_dotenv

load_dotenv(os.path.expanduser("~/.claude/.env"))

BRAND_NAME = "Tryambakam Noesis"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
OUT_DIR = os.path.join(SCRIPT_DIR, "..", "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/generated-v3")
os.makedirs(OUT_DIR, exist_ok=True)

# Skill reference images directory (composition references for Nano Banana Pro)
SKILL_REF_DIR = os.path.expanduser("~/.claude/skills/brandmint/references/images")

# =============================================================================
# PROVIDER CONFIGURATION
# =============================================================================
# Supports: fal (default), openrouter, openai, replicate
# Set IMAGE_PROVIDER env var or use --provider CLI flag

PROVIDER = os.environ.get("IMAGE_PROVIDER", "fal").lower()

# Provider-specific imports and setup
if PROVIDER == "fal":
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required for FAL provider. Install: pip install fal-client")
        sys.exit(1)
elif PROVIDER == "openrouter":
    if not os.environ.get("OPENROUTER_API_KEY"):
        print("ERROR: Set OPENROUTER_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "openai":
    if not os.environ.get("OPENAI_API_KEY"):
        print("ERROR: Set OPENAI_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "replicate":
    if not os.environ.get("REPLICATE_API_TOKEN"):
        print("ERROR: Set REPLICATE_API_TOKEN in ~/.claude/.env")
        sys.exit(1)
else:
    # Default to FAL for backward compatibility
    PROVIDER = "fal"
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required. Install: pip install fal-client")
        sys.exit(1)

print(f"Using image provider: {PROVIDER.upper()}")

NEGATIVE = """random logos, unrelated symbols, anime mascots, cluttered typography, v2 color system"""

# Brand logo file (for visual reference injection — empty if no logo configured)
LOGO_PATH = "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 1@8x.png"

_logo_url_cache = None
def get_logo_url():
    """Upload brand logo once and cache the URL for reuse."""
    global _logo_url_cache
    if _logo_url_cache:
        return _logo_url_cache
    if LOGO_PATH and os.path.exists(LOGO_PATH):
        print(f"  Uploading brand logo: {os.path.basename(LOGO_PATH)}")
        if PROVIDER == "fal":
            _logo_url_cache = fal_client.upload_file(LOGO_PATH)
        else:
            # For non-FAL providers, return local path (they may not support image refs)
            _logo_url_cache = LOGO_PATH
        return _logo_url_cache
    return None


# Product reference images (actual product photos for Nano Banana Pro accuracy)
PRODUCT_REF_PATHS = [
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 2@8x.png",
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 3@8x.png",
]

_product_ref_url_cache = None
def get_product_ref_urls():
    """Upload product reference images once and cache URLs for reuse."""
    global _product_ref_url_cache
    if _product_ref_url_cache is not None:
        return _product_ref_url_cache
    _product_ref_url_cache = []
    for p in PRODUCT_REF_PATHS:
        if os.path.exists(p):
            print(f"  Uploading product ref: {os.path.basename(p)}")
            if PROVIDER == "fal":
                _product_ref_url_cache.append(fal_client.upload_file(p))
            else:
                _product_ref_url_cache.append(p)
    return _product_ref_url_cache


# Reference image mapping: prompt ID -> composition reference filename
REF_IMAGES = {
    "2A": "ref-2A-bento-grid.jpg",
    "2B": "ref-2B-brand-seal.jpg",
    "2C": "ref-2C-logo-emboss.jpg",
    "3A": "ref-3A-capsule-collection.jpg",
    "3B": "ref-3B-hero-product.jpg",
    "3C": "ref-3C-essence-vial.jpg",
    "4A": "ref-4A-catalog-layout.jpg",
    "4B": "ref-4B-flatlay.jpg",
    "5A": "ref-5A-heritage-engraving.jpg",
    "5B": "ref-5B-campaign-grid.jpg",
    "5D": "ref-5D-engine-icons.jpg",
    "7A": "ref-7A-contact-sheet.jpg",
    "8A": "ref-8A-seeker-poster.jpg",
    "9A": "ref-9A-engine-poster.jpg",
    "10A": "ref-7A-contact-sheet.jpg",
    "10B": "ref-7A-contact-sheet.jpg",
    "10C": "ref-7A-contact-sheet.jpg",
}

# Config-driven reference image overrides
REF_OVERRIDES = {
    "3A": "ref-alt-leather-duffles.jpg",
}
REF_IMAGES.update(REF_OVERRIDES)


def get_ref_image(pid):
    """Get composition reference image path for a prompt ID."""
    fname = REF_IMAGES.get(pid, "")
    if fname:
        path = os.path.join(SKILL_REF_DIR, fname)
        if os.path.exists(path):
            return path
    return None


def download_image(url, filepath):
    resp = requests.get(url, timeout=120)
    resp.raise_for_status()
    with open(filepath, "wb") as f:
        f.write(resp.content)
    # Auto-convert JPEG-as-PNG: Flux 2 Pro returns JPEG but pipeline names files .png
    if filepath.endswith(".png"):
        with open(filepath, "rb") as f:
            header = f.read(4)
        if header[:2] == b"\xff\xd8":  # JPEG magic bytes
            import subprocess
            subprocess.run(["sips", "-s", "format", "png", filepath, "--out", filepath],
                         capture_output=True, check=True)
            print(f"  Converted JPEG -> PNG: {os.path.getsize(filepath) // 1024} KB")
    size_kb = os.path.getsize(filepath) / 1024
    print(f"  Saved: {os.path.basename(filepath)} ({size_kb:.0f} KB)")


# =============================================================================
# PROVIDER-AWARE GENERATION FUNCTIONS
# =============================================================================

def gen_with_openrouter(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenRouter API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENROUTER_API_KEY")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stabilityai/stable-diffusion-xl-base-1.0",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    payload = {"model": model_id, "prompt": prompt, "n": 1, "size": f"{width}x{height}"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://openrouter.ai/api/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_openai(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenAI DALL-E API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENAI_API_KEY")
    # DALL-E 3 has fixed sizes
    if width > height:
        size = "1792x1024"
    elif height > width:
        size = "1024x1792"
    else:
        size = "1024x1024"
    
    payload = {"model": "dall-e-3", "prompt": prompt, "n": 1, "size": size, "quality": "hd"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://api.openai.com/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_replicate(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using Replicate API."""
    import json
    import time
    import urllib.request
    
    api_key = os.environ.get("REPLICATE_API_TOKEN")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    # Create prediction
    payload = {"input": {"prompt": prompt, "width": width, "height": height}}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        f"https://api.replicate.com/v1/models/{model_id}/predictions",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=30) as resp:
        pred = json.loads(resp.read().decode("utf-8"))
    
    # Poll for completion
    pred_id = pred.get("id")
    for _ in range(60):
        time.sleep(5)
        req = urllib.request.Request(
            f"https://api.replicate.com/v1/predictions/{pred_id}",
            headers={"Authorization": f"Bearer {api_key}"},
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode("utf-8"))
        if result.get("status") == "succeeded":
            output = result.get("output")
            url = output[0] if isinstance(output, list) else output
            download_image(url, output_path)
            return True
        if result.get("status") in ("failed", "canceled"):
            return False
    return False


def gen_recraft(pid, slug, prompt, style, colors, size, seeds=(42, 137)):
    """Generate with Recraft V3 (or SDXL equivalent on other providers)."""
    # Parse size to dimensions for non-FAL providers
    size_dims = {"square": (1024, 1024), "landscape_16_9": (1792, 1024), 
                 "portrait_9_16": (1024, 1792), "1024x1024": (1024, 1024)}
    w, h = size_dims.get(size, (1024, 1024))
    
    for seed in seeds:
        variant = "v1" if seed == 42 else f"v{seed}"
        base_name = f"{pid}-{slug}-recraft-{variant}"
        print(f"\n  [{pid}] Recraft V3 ({style}) seed={seed} (provider: {PROVIDER})...")
        
        if PROVIDER == "fal":
            print(f"  Prompt length: {len(prompt)} chars")
            args = {
                "prompt": prompt,
                "image_size": size,
                "style": style,
                "seed": seed,
            }
            if colors:
                args["colors"] = [{"rgb": c} for c in colors]
            result = fal_client.subscribe(
                "fal-ai/recraft/v3/text-to-image",
                arguments=args,
            )
            img_url = result["images"][0]["url"]
            is_svg = img_url.endswith(".svg") or "vector" in style
            if is_svg:
                native_path = os.path.join(OUT_DIR, f"{base_name}.svg")
                download_image(img_url, native_path)
                png_path = os.path.join(OUT_DIR, f"{base_name}.png")
                try:
                    subprocess.run(
                        ["rsvg-convert", "-w", "2048", "-h", "2048",
                         "--keep-aspect-ratio", native_path, "-o", png_path],
                        check=True, capture_output=True,
                    )
                    sz = os.path.getsize(png_path) / 1024
                    print(f"  Converted SVG -> PNG: {sz:.0f} KB")
                except (subprocess.CalledProcessError, FileNotFoundError) as e:
                    print(f"  WARNING: SVG->PNG failed: {e}")
            else:
                native_path = os.path.join(OUT_DIR, f"{base_name}.webp")
                download_image(img_url, native_path)
                png_path = os.path.join(OUT_DIR, f"{base_name}.png")
                try:
                    subprocess.run(
                        ["sips", "-s", "format", "png", native_path, "--out", png_path],
                        check=True, capture_output=True,
                    )
                    sz = os.path.getsize(png_path) / 1024
                    print(f"  Converted WebP -> PNG: {sz:.0f} KB")
                except (subprocess.CalledProcessError, FileNotFoundError) as e:
                    print(f"  WARNING: WebP->PNG failed: {e}")
        else:
            # Non-FAL providers: use SDXL or equivalent (no SVG support)
            out_path = os.path.join(OUT_DIR, f"{base_name}.png")
            enhanced_prompt = f"{prompt}. Style: {style}. Fine line art, detailed illustration."
            if PROVIDER == "openrouter":
                gen_with_openrouter(enhanced_prompt, "recraft", out_path, w, h)
            elif PROVIDER == "openai":
                gen_with_openai(enhanced_prompt, "recraft", out_path, w, h)
            elif PROVIDER == "replicate":
                gen_with_replicate(enhanced_prompt, "recraft", out_path, w, h)


def gen_nano_banana(pid, slug, prompt, aspect, image_urls, seeds=(42, 137)):
    """Generate with Nano Banana Pro + style anchor (or equivalent on other providers)."""
    full_prompt = f"{prompt}\n\nAvoid: {NEGATIVE}"
    
    # Parse aspect ratio to get dimensions
    aspect_dims = {"16:9": (1792, 1024), "9:16": (1024, 1792), "1:1": (1024, 1024), 
                   "3:4": (896, 1152), "4:3": (1152, 896)}
    w, h = aspect_dims.get(aspect, (1024, 1024))
    
    for seed in seeds:
        variant = "v1" if seed == 42 else f"v{seed}"
        out_path = os.path.join(OUT_DIR, f"{pid}-{slug}-nanobananapro-{variant}.png")
        print(f"\n  [{pid}] Nano Banana Pro seed={seed} (provider: {PROVIDER})...")
        
        if PROVIDER == "fal":
            result = fal_client.subscribe(
                "fal-ai/nano-banana-pro",
                arguments={
                    "prompt": full_prompt,
                    "image_urls": image_urls,
                    "aspect_ratio": aspect,
                    "resolution": "2K",
                    "output_format": "png",
                    "seed": seed,
                    "num_images": 1,
                },
            )
            download_image(result["images"][0]["url"], out_path)
        elif PROVIDER == "openrouter":
            gen_with_openrouter(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "openai":
            gen_with_openai(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "replicate":
            gen_with_replicate(full_prompt, "nano-banana", out_path, w, h)


def gen_flux_pro(pid, slug, prompt, aspect, seeds=(42, 137)):
    """Generate with Flux 2 Pro (or equivalent on other providers)."""
    full_prompt = f"{prompt}\n\nAvoid: {NEGATIVE}"
    
    # Parse aspect to dimensions
    aspect_dims = {"landscape_16_9": (1792, 1024), "portrait_9_16": (1024, 1792), 
                   "square": (1024, 1024), "portrait_3_4": (896, 1152), "landscape_4_3": (1152, 896)}
    w, h = aspect_dims.get(aspect, (1024, 1024))
    
    for seed in seeds:
        variant = "v1" if seed == 42 else f"v{seed}"
        out_path = os.path.join(OUT_DIR, f"{pid}-{slug}-flux2pro-{variant}.png")
        print(f"\n  [{pid}] Flux 2 Pro seed={seed} (provider: {PROVIDER})...")
        
        if PROVIDER == "fal":
            result = fal_client.subscribe(
                "fal-ai/flux-2-pro",
                arguments={
                    "prompt": full_prompt,
                    "image_size": aspect,
                    "num_images": 1,
                    "seed": seed,
                },
            )
            download_image(result["images"][0]["url"], out_path)
        elif PROVIDER == "openrouter":
            gen_with_openrouter(full_prompt, "flux-2-pro", out_path, w, h)
        elif PROVIDER == "openai":
            gen_with_openai(full_prompt, "flux-2-pro", out_path, w, h)
        elif PROVIDER == "replicate":
            gen_with_replicate(full_prompt, "flux-2-pro", out_path, w, h)


PROMPT_5A = """Tryambakam Noesis heritage engraving logomark. heritage linework + computational geometry.
Thin delicate hairlines in organic curves. Airy, precise, no heavy borders.
Central sigil: canonical Tryambakam Noesis sigil from approved logo pack. Soma, Manas, Muladhara. Rendered as
botanical-scientific diagram. "Tryambakam Noesis" in geometric serif (Panchang
style), wide spacing. Below: "EST. MMXXVI" lighter weight. Flow Indigo
(#0B50FB) paper. Void Black (#070B1D) lines. Sacred Gold
(#C5A017) accent on borders."""

PROMPT_5B = """Tryambakam Noesis Campaign Visual Identity Grid. 2-column
asymmetrical layout. Full bleed, zero spacing between tiles.
Core metaphor: Observer light moving through embodied matter. Visual territory: .
TYPE A: Solid Void Black (#070B1D) background with pattern at 5% opacity,
centered sigil in Flow Indigo (#0B50FB).
TYPE B: Sacred Gold (#C5A017) background, "A Living System for Self-Authored Meaning" in Panchang
Bold, Flow Indigo text.
TYPE C: High-contrast duotone photographs using #070B1D + #C5A017.
Materials: oxidized copper, borosilicate glass, quartz, living moss, matte technical paper. hands not faces. Typography: Panchang ONLY.
Void Black 60% backgrounds. Flow Indigo 30% text/surfaces. Sacred Gold 10% highlights ONLY. Every photo unique. heritage linework + computational geometry."""

PROMPT_5C = """Tryambakam Noesis conceptual panel illustration. heritage linework + computational geometry.
engraving, schematic, minimal vector. Core metaphor: Observer light moving through embodied matter. Mood: precise, luminous, ritual, modular, editorial.
Flowing organic lines, flat color planes in Void Black
(#070B1D), Sacred Gold (#C5A017), and Coherence Emerald (#10B5A7).
Void Black 60% backgrounds. Flow Indigo 30% text/surfaces. Sacred Gold 10% highlights ONLY. Decorative border of flowing curves and organic tendrils. Grounded figure on
polished surface. Bio-digital structure elements with fiber-optic filaments
glowing Flow Indigo. No mystical imagery. Paper texture: warm, fibrous."""

STYLE_ANCHOR = os.path.join(OUT_DIR, "2A-brand-kit-bento-nanobananapro-v1.png")


def main():
    print("=" * 60)
    print(f"{BRAND_NAME} -- Illustrations + Icons (5A-5D)")
    print("=" * 60)

    # Verify Recraft prompt lengths
    for pid, p in {"5A": PROMPT_5A, "5C": PROMPT_5C}.items():
        count = len(p)
        status = "OK" if count < 1000 else "OVER LIMIT"
        print(f"  {pid}: {count} chars [{status}]")
        if count >= 1000:
            print("ERROR: Prompt exceeds 1000 char Recraft V3 limit. Condense it.")
            sys.exit(1)

    # 5A: Heritage Engraving (Recraft digital_illustration)
    print("\n--- 5A: Heritage Engraving (Recraft V3 digital) ---")
    gen_recraft("5A", "heritage-engraving", PROMPT_5A,
                "digital_illustration",
                ["#070B1D", "#0B50FB", "#C5A017"],
                "square_hd")

    # 5B: Campaign Grid (Nano Banana Pro + anchor + comp ref)
    print("\n--- 5B: Campaign Grid (Nano Banana Pro) ---")
    anchor_urls = []
    if os.path.exists(STYLE_ANCHOR):
        anchor_url = fal_client.upload_file(STYLE_ANCHOR)
        anchor_urls = [anchor_url]
    logo_url = get_logo_url()
    if logo_url:
        anchor_urls.append(logo_url)
    ref_5b = get_ref_image("5B")
    if ref_5b:
        print(f"  Adding composition ref: {os.path.basename(ref_5b)}")
        anchor_urls.append(fal_client.upload_file(ref_5b))
    gen_nano_banana("5B", "campaign-grid", PROMPT_5B, "3:4", anchor_urls)

    # 5C: Art Panel (Recraft digital_illustration)
    print("\n--- 5C: Art Panel (Recraft V3 digital) ---")
    gen_recraft("5C", "art-panel", PROMPT_5C,
                "digital_illustration",
                ["#070B1D", "#C5A017", "#10B5A7"],
                "portrait_4_3")

    # 5D-1: Vedic Engines Icons (Flux 2 Pro — default, PNG only)
    print("\n--- 5D-1: Vedic Engines Icons (Flux 2 Pro) ---")
    gen_flux_pro("5D-1", "vedic-engines-icons",
                 """0 clean, modern feature icons for Tryambakam Noesis "Vedic Engines".
Arranged in a 2x2 grid on clean Flow Indigo (#0B50FB) background.
Style: Flowing organic curves with circuit-trace precision. Professional iconography, no cartoon elements.
Each icon is a distinct, recognizable pictogram with consistent stroke weight.
Primary: Void Black (#070B1D). Accent: Sacred Gold (#C5A017).
No text labels. No newspaper or stamp aesthetic. Clean minimalist precision.
Icons: . 8K.""",
                 "square_hd")

    # 5D-2: Western Engines Icons (Flux 2 Pro — default, PNG only)
    print("\n--- 5D-2: Western Engines Icons (Flux 2 Pro) ---")
    gen_flux_pro("5D-2", "western-engines-icons",
                 """0 clean, modern feature icons for Tryambakam Noesis "Western Engines".
Arranged in a 2x2 grid on clean Flow Indigo (#0B50FB) background.
Style: Flowing organic curves with circuit-trace precision. Professional iconography, no cartoon elements.
Each icon is a distinct, recognizable pictogram with consistent stroke weight.
Primary: Void Black (#070B1D). Accent: Sacred Gold (#C5A017).
No text labels. No newspaper or stamp aesthetic. Clean minimalist precision.
Icons: . 8K.""",
                 "square_hd")

    print("\n" + "=" * 60)
    print("  ILLUSTRATIONS COMPLETE (5A-5D)")
    print("=" * 60)


if __name__ == "__main__":
    main()
