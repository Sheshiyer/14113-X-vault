#!/usr/bin/env python3
"""
Tryambakam Noesis — Style Anchor Bento Grid (2A)
Generated by Brandmint pipeline engine.

Provider: fal
"""
import os, sys, subprocess, requests
from dotenv import load_dotenv

load_dotenv(os.path.expanduser("~/.claude/.env"))

BRAND_NAME = "Tryambakam Noesis"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
OUT_DIR = os.path.join(SCRIPT_DIR, "..", "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/generated-v3")
os.makedirs(OUT_DIR, exist_ok=True)

# Skill reference images directory (composition references for Nano Banana Pro)
SKILL_REF_DIR = os.path.expanduser("~/.claude/skills/brandmint/references/images")

# =============================================================================
# PROVIDER CONFIGURATION
# =============================================================================
# Supports: fal (default), openrouter, openai, replicate
# Set IMAGE_PROVIDER env var or use --provider CLI flag

PROVIDER = os.environ.get("IMAGE_PROVIDER", "fal").lower()

# Provider-specific imports and setup
if PROVIDER == "fal":
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required for FAL provider. Install: pip install fal-client")
        sys.exit(1)
elif PROVIDER == "openrouter":
    if not os.environ.get("OPENROUTER_API_KEY"):
        print("ERROR: Set OPENROUTER_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "openai":
    if not os.environ.get("OPENAI_API_KEY"):
        print("ERROR: Set OPENAI_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "replicate":
    if not os.environ.get("REPLICATE_API_TOKEN"):
        print("ERROR: Set REPLICATE_API_TOKEN in ~/.claude/.env")
        sys.exit(1)
else:
    # Default to FAL for backward compatibility
    PROVIDER = "fal"
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required. Install: pip install fal-client")
        sys.exit(1)

print(f"Using image provider: {PROVIDER.upper()}")

NEGATIVE = """random logos, unrelated symbols, anime mascots, cluttered typography, v2 color system"""

# Brand logo file (for visual reference injection — empty if no logo configured)
LOGO_PATH = "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 1@8x.png"

_logo_url_cache = None
def get_logo_url():
    """Upload brand logo once and cache the URL for reuse."""
    global _logo_url_cache
    if _logo_url_cache:
        return _logo_url_cache
    if LOGO_PATH and os.path.exists(LOGO_PATH):
        print(f"  Uploading brand logo: {os.path.basename(LOGO_PATH)}")
        if PROVIDER == "fal":
            _logo_url_cache = fal_client.upload_file(LOGO_PATH)
        else:
            # For non-FAL providers, return local path (they may not support image refs)
            _logo_url_cache = LOGO_PATH
        return _logo_url_cache
    return None


# Product reference images (actual product photos for Nano Banana Pro accuracy)
PRODUCT_REF_PATHS = [
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 2@8x.png",
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 3@8x.png",
]

_product_ref_url_cache = None
def get_product_ref_urls():
    """Upload product reference images once and cache URLs for reuse."""
    global _product_ref_url_cache
    if _product_ref_url_cache is not None:
        return _product_ref_url_cache
    _product_ref_url_cache = []
    for p in PRODUCT_REF_PATHS:
        if os.path.exists(p):
            print(f"  Uploading product ref: {os.path.basename(p)}")
            if PROVIDER == "fal":
                _product_ref_url_cache.append(fal_client.upload_file(p))
            else:
                _product_ref_url_cache.append(p)
    return _product_ref_url_cache


# Reference image mapping: prompt ID -> composition reference filename
REF_IMAGES = {
    "2A": "ref-2A-bento-grid.jpg",
    "2B": "ref-2B-brand-seal.jpg",
    "2C": "ref-2C-logo-emboss.jpg",
    "3A": "ref-3A-capsule-collection.jpg",
    "3B": "ref-3B-hero-product.jpg",
    "3C": "ref-3C-essence-vial.jpg",
    "4A": "ref-4A-catalog-layout.jpg",
    "4B": "ref-4B-flatlay.jpg",
    "5A": "ref-5A-heritage-engraving.jpg",
    "5B": "ref-5B-campaign-grid.jpg",
    "5D": "ref-5D-engine-icons.jpg",
    "7A": "ref-7A-contact-sheet.jpg",
    "8A": "ref-8A-seeker-poster.jpg",
    "9A": "ref-9A-engine-poster.jpg",
    "10A": "ref-7A-contact-sheet.jpg",
    "10B": "ref-7A-contact-sheet.jpg",
    "10C": "ref-7A-contact-sheet.jpg",
}

# Config-driven reference image overrides
REF_OVERRIDES = {
    "3A": "ref-alt-leather-duffles.jpg",
}
REF_IMAGES.update(REF_OVERRIDES)


def get_ref_image(pid):
    """Get composition reference image path for a prompt ID."""
    fname = REF_IMAGES.get(pid, "")
    if fname:
        path = os.path.join(SKILL_REF_DIR, fname)
        if os.path.exists(path):
            return path
    return None


def download_image(url, filepath):
    resp = requests.get(url, timeout=120)
    resp.raise_for_status()
    with open(filepath, "wb") as f:
        f.write(resp.content)
    # Auto-convert JPEG-as-PNG: Flux 2 Pro returns JPEG but pipeline names files .png
    if filepath.endswith(".png"):
        with open(filepath, "rb") as f:
            header = f.read(4)
        if header[:2] == b"\xff\xd8":  # JPEG magic bytes
            import subprocess
            subprocess.run(["sips", "-s", "format", "png", filepath, "--out", filepath],
                         capture_output=True, check=True)
            print(f"  Converted JPEG -> PNG: {os.path.getsize(filepath) // 1024} KB")
    size_kb = os.path.getsize(filepath) / 1024
    print(f"  Saved: {os.path.basename(filepath)} ({size_kb:.0f} KB)")


# =============================================================================
# PROVIDER-AWARE GENERATION FUNCTIONS
# =============================================================================

def gen_with_openrouter(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenRouter API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENROUTER_API_KEY")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stabilityai/stable-diffusion-xl-base-1.0",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    payload = {"model": model_id, "prompt": prompt, "n": 1, "size": f"{width}x{height}"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://openrouter.ai/api/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_openai(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenAI DALL-E API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENAI_API_KEY")
    # DALL-E 3 has fixed sizes
    if width > height:
        size = "1792x1024"
    elif height > width:
        size = "1024x1792"
    else:
        size = "1024x1024"
    
    payload = {"model": "dall-e-3", "prompt": prompt, "n": 1, "size": size, "quality": "hd"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://api.openai.com/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_replicate(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using Replicate API."""
    import json
    import time
    import urllib.request
    
    api_key = os.environ.get("REPLICATE_API_TOKEN")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    # Create prediction
    payload = {"input": {"prompt": prompt, "width": width, "height": height}}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        f"https://api.replicate.com/v1/models/{model_id}/predictions",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=30) as resp:
        pred = json.loads(resp.read().decode("utf-8"))
    
    # Poll for completion
    pred_id = pred.get("id")
    for _ in range(60):
        time.sleep(5)
        req = urllib.request.Request(
            f"https://api.replicate.com/v1/predictions/{pred_id}",
            headers={"Authorization": f"Bearer {api_key}"},
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode("utf-8"))
        if result.get("status") == "succeeded":
            output = result.get("output")
            url = output[0] if isinstance(output, list) else output
            download_image(url, output_path)
            return True
        if result.get("status") in ("failed", "canceled"):
            return False
    return False


def gen_nano_banana(pid, slug, prompt, aspect, image_urls, seeds=(42, 137)):
    """Generate with Nano Banana Pro + style anchor (or equivalent on other providers)."""
    full_prompt = f"{prompt}\n\nAvoid: {NEGATIVE}"
    
    # Parse aspect ratio to get dimensions
    aspect_dims = {"16:9": (1792, 1024), "9:16": (1024, 1792), "1:1": (1024, 1024), 
                   "3:4": (896, 1152), "4:3": (1152, 896)}
    w, h = aspect_dims.get(aspect, (1024, 1024))
    
    for seed in seeds:
        variant = "v1" if seed == 42 else f"v{seed}"
        out_path = os.path.join(OUT_DIR, f"{pid}-{slug}-nanobananapro-{variant}.png")
        print(f"\n  [{pid}] Nano Banana Pro seed={seed} (provider: {PROVIDER})...")
        
        if PROVIDER == "fal":
            result = fal_client.subscribe(
                "fal-ai/nano-banana-pro",
                arguments={
                    "prompt": full_prompt,
                    "image_urls": image_urls,
                    "aspect_ratio": aspect,
                    "resolution": "2K",
                    "output_format": "png",
                    "seed": seed,
                    "num_images": 1,
                },
            )
            download_image(result["images"][0]["url"], out_path)
        elif PROVIDER == "openrouter":
            gen_with_openrouter(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "openai":
            gen_with_openai(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "replicate":
            gen_with_replicate(full_prompt, "nano-banana", out_path, w, h)


PROMPT_2A = """Tryambakam Noesis (Consciousness technology).
Act as a luxury Brand Director with uncompromising attention to craft. Create "Brand Identity System" presentation (Bento-Grid Layout).
Core metaphor: Observer light moving through embodied matter. Mood: precise, luminous, ritual, modular, editorial.

Generate a single high-resolution bento-grid board containing 6 distinct modules:

PHASE 1: VISUAL STRATEGY
1. Analyze the Brand: Archetype = "The Seasoned Cartographer" -- Grounded, direct, respectful-challenging.
   Visual vibe = Goethe Spectrum Systems, Bioluminescent architecture, sacred geometry, engineered ritual artifacts.
   Visual territory: .
2. Define the Palette: Void Black 60% backgrounds. Flow Indigo 30% text/surfaces. Sacred Gold 10% highlights ONLY.
   Void Black #070B1D, Flow Indigo #0B50FB,
   Sacred Gold #C5A017, Witness Violet #2D0050.
3. Select Typography: Panchang (headers, SemiBold/Bold, all caps). Satoshi (body).

PHASE 2: THE LAYOUT (6-MODULE GRID)
Block 1 (The Hero): High-contrast photograph of a hardcover codex with custom spine in Sacred Gold (#C5A017) material, pages made of fine craft paper, geometric diagrams visible on open pages in SF Mono resting on
polished surface inside quiet atelier / greenhouse hybrid. Warm Sacred Gold light.
Materials: oxidized copper, borosilicate glass, quartz, living moss, matte technical paper. Overlay "Tryambakam Noesis" wordmark in
Flow Indigo (#0B50FB), Panchang SemiBold, all caps.
Block 2 (Social Media): Instagram Post mockup -- Void Black (#070B1D)
background with subtle pattern overlay at 5% opacity, centered text in Panchang:
"" Sacred Gold accent line below.
Block 3 (The Palette): 5 Vertical Color Swatches -- #070B1D, #0B50FB,
#C5A017, #2D0050, #10B5A7. Simulated HEX codes.
Block 4 (Typography Spec): "Panchang" displayed prominently. Tiny "Primary
Typeface" subtext in Satoshi.
Block 5 (The Sigil): canonical Tryambakam Noesis sigil from approved logo pack. Soma, Manas, Muladhara.
Block 6 (Brand DNA): Manifesto Card -- ARCHETYPE: "The Seasoned Cartographer."
VOICE: "Grounded, direct, respectful-challenging." POSITIONING: "."
PILLARS: . VISUALS: "Bioluminescent architecture, sacred geometry, engineered ritual artifacts."

PHASE 3: AESTHETIC & FINISH
Style: Behance Trend / Awwwards Winner. Quality: 8K. 
Soft studio lighting with Sacred Gold rim accent. Sharp edges, 1px Witness Violet
borders. Generous white space. Optimized for DTC e-commerce: product-first imagery, flatlay grids, lifestyle context."""


def main():
    print("=" * 60)
    print(f"{BRAND_NAME} -- Style Anchor Bento Grid (2A)")
    print("Model: Nano Banana Pro | MUST RUN FIRST")
    print("=" * 60)

    # Upload composition reference image if available
    image_urls = []
    ref_path = get_ref_image("2A")
    if ref_path:
        print(f"\nUploading composition reference: {os.path.basename(ref_path)}")
        ref_url = fal_client.upload_file(ref_path)
        image_urls.append(ref_url)
    else:
        print("\nNo composition reference found for 2A (optional).")

    # Add brand logo as visual reference if available
    logo_url = get_logo_url()
    if logo_url:
        image_urls.append(logo_url)

    print("\n--- 2A: Brand Kit Bento Grid ---")
    gen_nano_banana("2A", "brand-kit-bento", PROMPT_2A, "16:9", image_urls)

    print("\n" + "=" * 60)
    print("  ANCHOR GENERATION COMPLETE (2A)")
    print("  This file is the STYLE ANCHOR for all subsequent generation.")
    print("=" * 60)


if __name__ == "__main__":
    main()
