<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TouchDesigner Style: Webcam + Perlin3D + Color Blend</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    canvas    { width:100%; height:100%; display:block; }
    #controls {
      position: absolute;
      top:10px; left:10px;
      color:#fff; font-family:sans-serif;
      user-select: none;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 8px;
      min-width: 200px;
    }
    #controls label {
      display: block;
      margin: 8px 0;
      font-size: 12px;
    }
    #controls input[type="range"] {
      width: 150px;
      margin-left: 10px;
    }
    #controls input[type="checkbox"] {
      margin-right: 8px;
    }
    .control-group {
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
      margin-bottom: 10px;
    }
    .control-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    .group-title {
      font-weight: bold;
      color: #ccc;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>

  <!-- hidden video source -->
  <video id="cam" playsinline muted style="display:none;"></video>
  <!-- our GL surface -->
  <canvas id="gl"></canvas>

  <!-- TouchDesigner-style controls -->
  <div id="controls">
    <div class="group-title">TouchDesigner Style Controls</div>
    
    <div class="control-group">
      <div class="group-title">Noise Parameters</div>
      <label>Seed: <span id="seedVal">1348</span>
        <input type="range" id="seed" min="0" max="9999" step="1" value="1348">
      </label>
      <label>Period: <span id="periodVal">0.22</span>
        <input type="range" id="period" min="0.01" max="2.0" step="0.01" value="0.22">
      </label>
      <label>Harmonics: <span id="harmonicsVal">2</span>
        <input type="range" id="harmonics" min="0" max="8" step="1" value="2">
      </label>
      <label>Harmonic Spread: <span id="spreadVal">2.6</span>
        <input type="range" id="spread" min="1.0" max="4.0" step="0.1" value="2.6">
      </label>
      <label>Harmonic Gain: <span id="gainVal">0.7</span>
        <input type="range" id="gain" min="0.0" max="1.0" step="0.01" value="0.7">
      </label>
      <label>Roughness: <span id="roughnessVal">0.5</span>
        <input type="range" id="roughness" min="0.0" max="1.0" step="0.01" value="0.5">
      </label>
      <label>Exponent: <span id="exponentVal">0.5</span>
        <input type="range" id="exponent" min="0.1" max="3.0" step="0.01" value="0.5">
      </label>
      <label>Amplitude: <span id="amplitudeVal">0.53</span>
        <input type="range" id="amplitude" min="0.0" max="2.0" step="0.01" value="0.53">
      </label>
      <label>Offset: <span id="offsetVal">0.5</span>
        <input type="range" id="offset" min="0.0" max="1.0" step="0.01" value="0.5">
      </label>
    </div>
    
    <div class="control-group">
      <div class="group-title">Animation</div>
      <label>Speed: <span id="speedVal">1.0</span>
        <input type="range" id="speed" min="0.0" max="3.0" step="0.1" value="1.0">
      </label>
      <label><input type="checkbox" id="monochrome"> Monochrome</label>
    </div>
    
    <div class="control-group">
      <div class="group-title">Blend</div>
      <label>Intensity: <span id="intensityVal">1.0</span>
        <input type="range" id="intensity" min="0.0" max="2.0" step="0.01" value="1.0">
      </label>
    </div>
  </div>

  <script type="module">
  // ———————————— Boilerplate & getUserMedia ————————————
  const video  = document.getElementById('cam');
  const canvas = document.getElementById('gl');
  const gl     = canvas.getContext('webgl2', {premultipliedAlpha:false});
  if(!gl) throw new Error("WebGL2 required");

  // resize canvas to fill
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    if(canvas.width!==w || canvas.height!==h){
      canvas.width=w; canvas.height=h;
      gl.viewport(0,0,w,h);
    }
  }
  window.addEventListener('resize', resize);
  resize();

  // ask camera
  navigator.mediaDevices.getUserMedia({video:{width:640,height:480}})
    .then(s => { video.srcObject = s; return video.play() })
    .then(init)
    .catch(e=> alert("Camera error: "+e.message))

  // ———————————— init GL ————————————
  function init(){
    // compile shaders + link
    const prog = createProgram(gl, vertexSrc, fragmentSrc);
    gl.useProgram(prog);

    // full-screen triangle
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const posBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    // 3 verts cover entire screen
    gl.bufferData(gl.ARRAY_BUFFER,
      new Float32Array([ -1,-1,  3,-1,  -1,3 ]),
      gl.STATIC_DRAW
    );
    const aPos = gl.getAttribLocation(prog,'aPosition');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    // single video texture
    const videoTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, videoTex);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);

    // uniform locations
    const uni = {
      uVideo:        gl.getUniformLocation(prog,'uVideo'),
      uTime:         gl.getUniformLocation(prog,'uTime'),
      uSeed:         gl.getUniformLocation(prog,'uSeed'),
      uPeriod:       gl.getUniformLocation(prog,'uPeriod'),
      uHarmonics:    gl.getUniformLocation(prog,'uHarmonics'),
      uSpread:       gl.getUniformLocation(prog,'uSpread'),
      uGain:         gl.getUniformLocation(prog,'uGain'),
      uRoughness:    gl.getUniformLocation(prog,'uRoughness'),
      uExponent:     gl.getUniformLocation(prog,'uExponent'),
      uAmplitude:    gl.getUniformLocation(prog,'uAmplitude'),
      uOffset:       gl.getUniformLocation(prog,'uOffset'),
      uMonochrome:   gl.getUniformLocation(prog,'uMonochrome'),
      uSpeed:        gl.getUniformLocation(prog,'uSpeed'),
      uIntensity:    gl.getUniformLocation(prog,'uIntensity'),
    };

    // bind our video sampler to texture unit 0
    gl.uniform1i(uni.uVideo, 0);

    // UI controls
    const controls = {
      seed: document.getElementById('seed'),
      period: document.getElementById('period'),
      harmonics: document.getElementById('harmonics'),
      spread: document.getElementById('spread'),
      gain: document.getElementById('gain'),
      roughness: document.getElementById('roughness'),
      exponent: document.getElementById('exponent'),
      amplitude: document.getElementById('amplitude'),
      offset: document.getElementById('offset'),
      speed: document.getElementById('speed'),
      monochrome: document.getElementById('monochrome'),
      intensity: document.getElementById('intensity')
    };

    // Value display elements
    const displays = {
      period: document.getElementById('periodVal'),
      octaves: document.getElementById('octavesVal'),
      amplitude: document.getElementById('amplitudeVal'),
      offset: document.getElementById('offsetVal'),
      gain: document.getElementById('gainVal'),
      spread: document.getElementById('spreadVal'),
      speed: document.getElementById('speedVal'),
      intensity: document.getElementById('intensityVal')
    };

    // Update display values
    function updateDisplays() {
      Object.keys(displays).forEach(key => {
        if(controls[key] && displays[key]) {
          displays[key].textContent = controls[key].value;
        }
      });
    }

    // Add event listeners
    Object.keys(controls).forEach(key => {
      if(controls[key]) {
        controls[key].addEventListener('input', updateDisplays);
      }
    });

    // animation loop
    const t0 = performance.now();
    function draw(){
      resize();
      gl.clear(gl.COLOR_BUFFER_BIT);

      // upload current camera frame
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, videoTex);
      gl.texImage2D(
        gl.TEXTURE_2D,0,gl.RGB,gl.RGB,gl.UNSIGNED_BYTE,video
      );

      // update uniforms from controls
      const t = (performance.now() - t0) * 0.001 * parseFloat(controls.speed.value);
      gl.uniform1f(uni.uTime, t);
      gl.uniform1f(uni.uSeed, parseFloat(controls.seed.value));
      gl.uniform1f(uni.uPeriod, parseFloat(controls.period.value));
      gl.uniform1i(uni.uHarmonics, parseInt(controls.harmonics.value));
      gl.uniform1f(uni.uSpread, parseFloat(controls.spread.value));
      gl.uniform1f(uni.uGain, parseFloat(controls.gain.value));
      gl.uniform1f(uni.uRoughness, parseFloat(controls.roughness.value));
      gl.uniform1f(uni.uExponent, parseFloat(controls.exponent.value));
      gl.uniform1f(uni.uAmplitude, parseFloat(controls.amplitude.value));
      gl.uniform1f(uni.uOffset, parseFloat(controls.offset.value));
      gl.uniform1i(uni.uMonochrome, controls.monochrome.checked ? 1 : 0);
      gl.uniform1f(uni.uIntensity, parseFloat(controls.intensity.value));

      // draw that single triangle
      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLES, 0, 3);

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  }

  // ———————————— GLSL sources ————————————
  const vertexSrc = `#version 300 es
  in vec2 aPosition;
  out vec2 vUV;
  void main(){
    vUV = aPosition * 0.5 + 0.5;
    vUV.y = 1.0 - vUV.y;  // Flip Y coordinate to fix upside-down video
    gl_Position = vec4(aPosition,0.,1.);
  }`;

  const fragmentSrc = `#version 300 es
  precision highp float;
  in vec2 vUV;
  out vec4 fragColor;

  uniform sampler2D uVideo;
  uniform float uTime;
  uniform float uSeed;
  uniform float uPeriod;
  uniform int   uHarmonics;
  uniform float uSpread;
  uniform float uGain;
  uniform float uRoughness;
  uniform float uExponent;
  uniform float uAmplitude;
  uniform float uOffset;
  uniform int   uMonochrome;
  uniform float uIntensity;

  // ————— 3D Simplex (Ashima) + fbm —————
  vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 mod289(vec4 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }

  float snoise(vec3 v){
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0,0.5,1.0,2.0);
    vec3 i = floor(v + dot(v,C.yyy));
    vec3 x0= v - i + dot(i,C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1= min(g.xyz,l.zxy), i2= max(g.xyz,l.zxy);
    vec3 x1= x0 - i1 + C.xxx;
    vec3 x2= x0 - i2 + C.yyy;
    vec3 x3= x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute( permute( permute(
      i.z + vec4(0.0,i1.z,i2.z,1.0))
      + i.y + vec4(0.0,i1.y,i2.y,1.0))
      + i.x + vec4(0.0,i1.x,i2.x,1.0));
    vec4 j = p - 49.0*floor(p*(1.0/49.0));
    vec4 x_ = floor(j*(1.0/7.0));
    vec4 y_ = floor(j - 7.0*x_);
    vec4 x = x_*(1.0/7.0) + (1.0/14.0);
    vec4 y = y_*(1.0/7.0) + (1.0/14.0);
    vec4 h = 1.0 - abs(x)-abs(y);
    vec4 b0 = vec4(x.xy,y.xy), b1 = vec4(x.zw,y.zw);
    vec4 s0 = floor(b0)*2.0+1.0, s1 = floor(b1)*2.0+1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0=vec3(a0.xy,h.x), p1=vec3(a0.zw,h.y),
         p2=vec3(a1.xy,h.z), p3=vec3(a1.zw,h.w);
    vec4 norm = taylorInvSqrt(vec4(
      dot(p0,p0), dot(p1,p1),
      dot(p2,p2), dot(p3,p3)));
    p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
    vec4 m = max(0.6 - vec4(
      dot(x0,x0), dot(x1,x1),
      dot(x2,x2), dot(x3,x3)), 0.0);
    m = m*m;
    return 42.0 * dot(m*m, vec4(
      dot(p0,x0), dot(p1,x1),
      dot(p2,x2), dot(p3,x3)));
  }

  float fbm(vec3 p){
    // Add seed offset
    p += vec3(uSeed * 0.001);
    
    float f = 0.0;
    float amp = 1.0;
    float maxValue = 0.0;
    
    for(int i = 0; i < 8; i++){
      if(i >= uHarmonics) break;
      
      float n = snoise(p);
      
      // Apply roughness (affects how each octave contributes)
      float roughAmp = amp * (1.0 - uRoughness * float(i) / 8.0);
      
      f += roughAmp * n;
      maxValue += roughAmp;
      
      p *= uSpread;
      amp *= uGain;
    }
    
    // Normalize by max possible value
    if(maxValue > 0.0) {
      f /= maxValue;
    }
    
    // Apply exponent
    f = sign(f) * pow(abs(f), uExponent);
    
    return f;
  }

  // ————— HSL helpers & Color-blend —————
  vec3 rgb2hsl(vec3 c){
    float M = max(c.r,max(c.g,c.b)),
          m = min(c.r,min(c.g,c.b)),
          d = M - m,
          l = (M+m)*0.5,
          s = d==0.0?0.0:d/(1.0-abs(2.0*l-1.0));
    float h=0.0;
    if(d>0.0){
      if(M==c.r) h = mod((c.g-c.b)/d + (c.g<c.b?6.0:0.0),6.0);
      else if(M==c.g) h = (c.b-c.r)/d +2.0;
      else h = (c.r-c.g)/d +4.0;
      h/=6.0;
    }
    return vec3(h,s,l);
  }
  float hue2rgb(float p, float q, float t){
    if(t<0.0) t+=1.0;
    if(t>1.0) t-=1.0;
    if(t<1.0/6.0) return p+(q-p)*6.0*t;
    if(t<1.0/2.0) return q;
    if(t<2.0/3.0) return p+(q-p)*(2.0/3.0-t)*6.0;
    return p;
  }
  vec3 hsl2rgb(vec3 c){
    float h=c.x, s=c.y, l=c.z;
    if(s==0.0) return vec3(l);
    float q = l<0.5?l*(1.0+s):l+s-l*s,
          p = 2.0*l - q;
    return vec3(
      hue2rgb(p,q,h+1.0/3.0),
      hue2rgb(p,q,h),
      hue2rgb(p,q,h-1.0/3.0)
    );
  }
  
  // TouchDesigner Color blend mode
  vec3 colorBlend(vec3 base, vec3 overlay){
    vec3 hslBase = rgb2hsl(base);
    vec3 hslOverlay = rgb2hsl(overlay);
    // Keep base luminance, use overlay hue and saturation
    return hsl2rgb(vec3(hslOverlay.x, hslOverlay.y, hslBase.z));
  }

  void main(){
    vec3 videoCol = texture(uVideo, vUV).rgb;
    
    // Generate 3D Perlin noise (TouchDesigner style)
    // Period in TouchDesigner is frequency - smaller values = larger patterns
    float frequency = 1.0 / max(uPeriod, 0.001);
    float n = fbm(vec3(vUV * frequency, uTime));
    
    // Apply amplitude and offset
    n = n * uAmplitude + uOffset;
    
    // Clamp to [0,1] range like TouchDesigner
    n = clamp(n, 0.0, 1.0);
    
    vec3 final;
    
    if(uMonochrome == 1) {
      // For monochrome noise filter: modulate brightness/luminance
      // Map noise from [0,1] to a range around 1.0 based on intensity
      float noiseMultiplier = 1.0 + (n - 0.5) * uIntensity * 2.0;
      final = videoCol * noiseMultiplier;
    } else {
      // TouchDesigner Color blend mode: Keep video luminosity, use noise hue/saturation
      // Generate separate noise for R, G, B channels
      vec2 uvFreq = vUV * frequency;
      float rNoise = fbm(vec3(uvFreq + vec2(100.0), uTime));
      float gNoise = fbm(vec3(uvFreq + vec2(200.0), uTime));
      float bNoise = fbm(vec3(uvFreq + vec2(300.0), uTime));
      
      // Apply amplitude and offset to each channel
      rNoise = clamp(rNoise * uAmplitude + uOffset, 0.0, 1.0);
      gNoise = clamp(gNoise * uAmplitude + uOffset, 0.0, 1.0);
      bNoise = clamp(bNoise * uAmplitude + uOffset, 0.0, 1.0);
      
      // Create noise color
      vec3 noiseColor = vec3(rNoise, gNoise, bNoise);
      
      // Convert video and noise to HSL
      vec3 videoHSL = rgb2hsl(videoCol);
      vec3 noiseHSL = rgb2hsl(noiseColor);
      
      // Color blend: Keep video luminosity, use noise hue/saturation
      vec3 blendedHSL = vec3(noiseHSL.x, noiseHSL.y, videoHSL.z);
      vec3 blendedRGB = hsl2rgb(blendedHSL);
      
      // Mix between original video and color-blended result based on intensity
      final = mix(videoCol, blendedRGB, uIntensity);
    }
    
    fragColor = vec4(final, 1.0);
  }`;

  // ———————————— GL helper fns ————————————
  function createShader(gl, type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
  }
  function createProgram(gl, vsrc, fsrc){
    const v = createShader(gl, gl.VERTEX_SHADER,   vsrc);
    const f = createShader(gl, gl.FRAGMENT_SHADER, fsrc);
    const p = gl.createProgram();
    gl.attachShader(p,v);
    gl.attachShader(p,f);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
  }
  </script>
</body>
</html>