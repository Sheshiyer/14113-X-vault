#!/usr/bin/env python3
"""
Tryambakam Noesis — Campaign Posters (8A + 9A + 10A-C)
Generated by Brandmint pipeline engine.

Provider: fal
"""
import os, sys, subprocess, requests
from dotenv import load_dotenv

load_dotenv(os.path.expanduser("~/.claude/.env"))

BRAND_NAME = "Tryambakam Noesis"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
OUT_DIR = os.path.join(SCRIPT_DIR, "..", "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/generated-v3")
os.makedirs(OUT_DIR, exist_ok=True)

# Skill reference images directory (composition references for Nano Banana Pro)
SKILL_REF_DIR = os.path.expanduser("~/.claude/skills/brandmint/references/images")

# =============================================================================
# PROVIDER CONFIGURATION
# =============================================================================
# Supports: fal (default), openrouter, openai, replicate
# Set IMAGE_PROVIDER env var or use --provider CLI flag

PROVIDER = os.environ.get("IMAGE_PROVIDER", "fal").lower()

# Provider-specific imports and setup
if PROVIDER == "fal":
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required for FAL provider. Install: pip install fal-client")
        sys.exit(1)
elif PROVIDER == "openrouter":
    if not os.environ.get("OPENROUTER_API_KEY"):
        print("ERROR: Set OPENROUTER_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "openai":
    if not os.environ.get("OPENAI_API_KEY"):
        print("ERROR: Set OPENAI_API_KEY in ~/.claude/.env")
        sys.exit(1)
elif PROVIDER == "replicate":
    if not os.environ.get("REPLICATE_API_TOKEN"):
        print("ERROR: Set REPLICATE_API_TOKEN in ~/.claude/.env")
        sys.exit(1)
else:
    # Default to FAL for backward compatibility
    PROVIDER = "fal"
    try:
        import fal_client
        if not os.environ.get("FAL_KEY"):
            print("ERROR: Set FAL_KEY in ~/.claude/.env")
            sys.exit(1)
    except ImportError:
        print("ERROR: fal_client required. Install: pip install fal-client")
        sys.exit(1)

print(f"Using image provider: {PROVIDER.upper()}")

NEGATIVE = """random logos, unrelated symbols, anime mascots, cluttered typography, v2 color system"""

# Brand logo file (for visual reference injection — empty if no logo configured)
LOGO_PATH = "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 1@8x.png"

_logo_url_cache = None
def get_logo_url():
    """Upload brand logo once and cache the URL for reuse."""
    global _logo_url_cache
    if _logo_url_cache:
        return _logo_url_cache
    if LOGO_PATH and os.path.exists(LOGO_PATH):
        print(f"  Uploading brand logo: {os.path.basename(LOGO_PATH)}")
        if PROVIDER == "fal":
            _logo_url_cache = fal_client.upload_file(LOGO_PATH)
        else:
            # For non-FAL providers, return local path (they may not support image refs)
            _logo_url_cache = LOGO_PATH
        return _logo_url_cache
    return None


# Product reference images (actual product photos for Nano Banana Pro accuracy)
PRODUCT_REF_PATHS = [
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 2@8x.png",
    "/Volumes/madara/2026/twc-vault/01-Projects/tryambakam-noesis/brand-docs-final/Brand Visual Identity/logo/8x/Asset 3@8x.png",
]

_product_ref_url_cache = None
def get_product_ref_urls():
    """Upload product reference images once and cache URLs for reuse."""
    global _product_ref_url_cache
    if _product_ref_url_cache is not None:
        return _product_ref_url_cache
    _product_ref_url_cache = []
    for p in PRODUCT_REF_PATHS:
        if os.path.exists(p):
            print(f"  Uploading product ref: {os.path.basename(p)}")
            if PROVIDER == "fal":
                _product_ref_url_cache.append(fal_client.upload_file(p))
            else:
                _product_ref_url_cache.append(p)
    return _product_ref_url_cache


# Reference image mapping: prompt ID -> composition reference filename
REF_IMAGES = {
    "2A": "ref-2A-bento-grid.jpg",
    "2B": "ref-2B-brand-seal.jpg",
    "2C": "ref-2C-logo-emboss.jpg",
    "3A": "ref-3A-capsule-collection.jpg",
    "3B": "ref-3B-hero-product.jpg",
    "3C": "ref-3C-essence-vial.jpg",
    "4A": "ref-4A-catalog-layout.jpg",
    "4B": "ref-4B-flatlay.jpg",
    "5A": "ref-5A-heritage-engraving.jpg",
    "5B": "ref-5B-campaign-grid.jpg",
    "5D": "ref-5D-engine-icons.jpg",
    "7A": "ref-7A-contact-sheet.jpg",
    "8A": "ref-8A-seeker-poster.jpg",
    "9A": "ref-9A-engine-poster.jpg",
    "10A": "ref-7A-contact-sheet.jpg",
    "10B": "ref-7A-contact-sheet.jpg",
    "10C": "ref-7A-contact-sheet.jpg",
}

# Config-driven reference image overrides
REF_OVERRIDES = {
    "3A": "ref-alt-leather-duffles.jpg",
}
REF_IMAGES.update(REF_OVERRIDES)


def get_ref_image(pid):
    """Get composition reference image path for a prompt ID."""
    fname = REF_IMAGES.get(pid, "")
    if fname:
        path = os.path.join(SKILL_REF_DIR, fname)
        if os.path.exists(path):
            return path
    return None


def download_image(url, filepath):
    resp = requests.get(url, timeout=120)
    resp.raise_for_status()
    with open(filepath, "wb") as f:
        f.write(resp.content)
    # Auto-convert JPEG-as-PNG: Flux 2 Pro returns JPEG but pipeline names files .png
    if filepath.endswith(".png"):
        with open(filepath, "rb") as f:
            header = f.read(4)
        if header[:2] == b"\xff\xd8":  # JPEG magic bytes
            import subprocess
            subprocess.run(["sips", "-s", "format", "png", filepath, "--out", filepath],
                         capture_output=True, check=True)
            print(f"  Converted JPEG -> PNG: {os.path.getsize(filepath) // 1024} KB")
    size_kb = os.path.getsize(filepath) / 1024
    print(f"  Saved: {os.path.basename(filepath)} ({size_kb:.0f} KB)")


# =============================================================================
# PROVIDER-AWARE GENERATION FUNCTIONS
# =============================================================================

def gen_with_openrouter(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenRouter API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENROUTER_API_KEY")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stabilityai/stable-diffusion-xl-base-1.0",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    payload = {"model": model_id, "prompt": prompt, "n": 1, "size": f"{width}x{height}"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://openrouter.ai/api/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_openai(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using OpenAI DALL-E API."""
    import json
    import urllib.request
    
    api_key = os.environ.get("OPENAI_API_KEY")
    # DALL-E 3 has fixed sizes
    if width > height:
        size = "1792x1024"
    elif height > width:
        size = "1024x1792"
    else:
        size = "1024x1024"
    
    payload = {"model": "dall-e-3", "prompt": prompt, "n": 1, "size": size, "quality": "hd"}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        "https://api.openai.com/v1/images/generations",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=120) as resp:
        result = json.loads(resp.read().decode("utf-8"))
    if "data" in result and result["data"]:
        download_image(result["data"][0]["url"], output_path)
        return True
    return False


def gen_with_replicate(prompt, model, output_path, width=1024, height=1024, **kwargs):
    """Generate image using Replicate API."""
    import json
    import time
    import urllib.request
    
    api_key = os.environ.get("REPLICATE_API_TOKEN")
    model_map = {
        "nano-banana": "black-forest-labs/flux-1.1-pro",
        "flux-2-pro": "black-forest-labs/flux-1.1-pro",
        "recraft": "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    }
    model_id = model_map.get(model, "black-forest-labs/flux-1.1-pro")
    
    # Create prediction
    payload = {"input": {"prompt": prompt, "width": width, "height": height}}
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        f"https://api.replicate.com/v1/models/{model_id}/predictions",
        data=data,
        headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"},
    )
    with urllib.request.urlopen(req, timeout=30) as resp:
        pred = json.loads(resp.read().decode("utf-8"))
    
    # Poll for completion
    pred_id = pred.get("id")
    for _ in range(60):
        time.sleep(5)
        req = urllib.request.Request(
            f"https://api.replicate.com/v1/predictions/{pred_id}",
            headers={"Authorization": f"Bearer {api_key}"},
        )
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode("utf-8"))
        if result.get("status") == "succeeded":
            output = result.get("output")
            url = output[0] if isinstance(output, list) else output
            download_image(url, output_path)
            return True
        if result.get("status") in ("failed", "canceled"):
            return False
    return False


def gen_nano_banana(pid, slug, prompt, aspect, image_urls, seeds=(42, 137)):
    """Generate with Nano Banana Pro + style anchor (or equivalent on other providers)."""
    full_prompt = f"{prompt}\n\nAvoid: {NEGATIVE}"
    
    # Parse aspect ratio to get dimensions
    aspect_dims = {"16:9": (1792, 1024), "9:16": (1024, 1792), "1:1": (1024, 1024), 
                   "3:4": (896, 1152), "4:3": (1152, 896)}
    w, h = aspect_dims.get(aspect, (1024, 1024))
    
    for seed in seeds:
        variant = "v1" if seed == 42 else f"v{seed}"
        out_path = os.path.join(OUT_DIR, f"{pid}-{slug}-nanobananapro-{variant}.png")
        print(f"\n  [{pid}] Nano Banana Pro seed={seed} (provider: {PROVIDER})...")
        
        if PROVIDER == "fal":
            result = fal_client.subscribe(
                "fal-ai/nano-banana-pro",
                arguments={
                    "prompt": full_prompt,
                    "image_urls": image_urls,
                    "aspect_ratio": aspect,
                    "resolution": "2K",
                    "output_format": "png",
                    "seed": seed,
                    "num_images": 1,
                },
            )
            download_image(result["images"][0]["url"], out_path)
        elif PROVIDER == "openrouter":
            gen_with_openrouter(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "openai":
            gen_with_openai(full_prompt, "nano-banana", out_path, w, h)
        elif PROVIDER == "replicate":
            gen_with_replicate(full_prompt, "nano-banana", out_path, w, h)


PROMPT_8A = """Tryambakam Noesis "The Seeker" conceptual portrait poster.
Core metaphor: Observer light moving through embodied matter.
A solitary figure seen from behind -- standing still, contemplative posture.
No face visible. Full body, centered in frame.
SPLIT COMPOSITION: LEFT HALF shows material reality -- ultra-photorealistic detail:
hand texture, fabric weave, polished floor, quiet atelier / greenhouse hybrid visible behind.
RIGHT HALF shows inner architecture -- translucent technical blueprint revealing:
circuit-trace diagrams, fiber-optic filaments glowing Flow Indigo (#0B50FB),
engineering nodes at key body points, network patterns from feet.
The split line glows Sacred Gold (#C5A017).
COLOR: Void Black 60% backgrounds. Flow Indigo 30% text/surfaces. Sacred Gold 10% highlights ONLY. Void Black dominant, Sacred Gold highlights, Flow Indigo inner glow,
Coherence Emerald (#10B5A7) for living elements. Film grain.
Typography: "THE SEEKER" in Panchang SemiBold, Witness Violet (#2D0050).
Audience aesthetic: . Emotional register: ."""

PROMPT_9A_BASE = """Tryambakam Noesis campaign poster. Single {object} centered on
{bg_color} ({bg_hex}) background. The object rendered as physical bio-digital artifact
artifact -- part {material_a}, part {material_b}, with fiber-optic filaments
glowing Flow Indigo (#0B50FB). Art Deco geometric border frame in
Sacred Gold (#C5A017). Typography bottom third: "{engine_name}" in
Panchang Bold, all caps, Flow Indigo (#0B50FB).
Below: "{tagline}" in Panchang Light, Witness Violet (#2D0050).
Bottom: "Tryambakam Noesis" in Satoshi Regular. Dramatic top-down spotlight. 8K."""

PROMPT_10_BASE = """Tryambakam Noesis "{sequence_title}" sequential practice narrative.
3x3 grid of 9 panels showing hands-only progression.
No face -- only hands and forearms. Same hands across all 9 panels.
Environment: quiet atelier / greenhouse hybrid. Materials: oxidized copper, borosilicate glass, quartz, living moss, matte technical paper.
9 PANELS: {panel_descriptions}
Camera: medium-format look, 80mm. Sacred Gold (#C5A017) highlights,
Void Black (#070B1D) deep shadows. 2px Witness Violet borders. 8K."""

ENGINES = {
}

SEQUENCES = {
}

STYLE_ANCHOR = os.path.join(OUT_DIR, "2A-brand-kit-bento-nanobananapro-v1.png")


def main():
    print("=" * 60)
    print(f"{BRAND_NAME} -- Campaign Posters")
    print("Model: Nano Banana Pro")
    print("=" * 60)

    image_urls = []
    if os.path.exists(STYLE_ANCHOR):
        print("Uploading style anchor...")
        anchor_url = fal_client.upload_file(STYLE_ANCHOR)
        image_urls = [anchor_url]
    else:
        print("WARNING: Style anchor not found.")

    logo_url = get_logo_url()
    if logo_url:
        image_urls.append(logo_url)
    # Product reference images for model accuracy
    for purl in get_product_ref_urls():
        image_urls.append(purl)

    # 8A: Seeker poster (with composition reference)
    print("\n--- 8A: Seeker Poster ---")
    urls_8a = list(image_urls)
    ref_8a = get_ref_image("8A")
    if ref_8a:
        print(f"  Adding composition ref: {os.path.basename(ref_8a)}")
        urls_8a.append(fal_client.upload_file(ref_8a))
    gen_nano_banana("8A", "seeker-poster", PROMPT_8A, "3:4", urls_8a,
                    seeds=(42, 137, 256))

    # 9A: Individual engine posters (with composition reference)
    if ENGINES:
        print("\n--- 9A: Engine Posters ---")
        urls_9a = list(image_urls)
        ref_9a = get_ref_image("9A")
        if ref_9a:
            print(f"  Adding composition ref: {os.path.basename(ref_9a)}")
            urls_9a.append(fal_client.upload_file(ref_9a))
        for eid, edata in ENGINES.items():
            prompt = PROMPT_9A_BASE.format(**edata)
            slug = edata["name"].lower().replace(" ", "-").replace("&", "and")
            print(f"\n  [{eid}] {edata['name']}...")
            gen_nano_banana(eid, f"{slug}-poster", prompt, "3:4", urls_9a,
                            seeds=(42,))

    # 10A-C: Ritual sequences (with grid composition reference)
    if SEQUENCES:
        print("\n--- 10A-C: Practice Sequences ---")
        urls_10 = list(image_urls)
        ref_10 = get_ref_image("10A")
        if ref_10:
            print(f"  Adding grid composition ref: {os.path.basename(ref_10)}")
            urls_10.append(fal_client.upload_file(ref_10))
        for skey, sdata in SEQUENCES.items():
            sid = sdata["id"]
            prompt = PROMPT_10_BASE.format(
                sequence_title=sdata["title"],
                panel_descriptions=sdata["panels"],
            )
            slug = sdata["title"].lower().replace(" ", "-")
            print(f"\n  [{sid}] {sdata['title']}...")
            gen_nano_banana(sid, slug, prompt, "1:1", urls_10)


    print("\n" + "=" * 60)
    print("  POSTERS COMPLETE")
    print("=" * 60)


if __name__ == "__main__":
    main()
